// ⚠️  DEPLOYMENT REQUIRED after ANY edit to this file.
// Run: firebase deploy --only firestore:rules
// Last deployed: 2026-02-20
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ═══════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS
    // ═══════════════════════════════════════════════════════════════
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the owner of a resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user is admin
    // ADMIN FEATURE DISABLED FOR CLEAN TESTING
    // To enable: Uncomment the email below when admin dashboard is ready
    function isAdmin() {
      return isAuthenticated() && request.auth.token.email in [
        // 'riscomics@gmail.com'  // Commented out for testing as regular user
      ];
    }
    
    // Validate profile data structure
    function isValidProfile() {
      return request.resource.data.keys().hasAll(['userId', 'fullName', 'email', 'accountCreated'])
        && request.resource.data.userId is string
        && request.resource.data.fullName is string
        && request.resource.data.email is string
        && request.resource.data.fullName.size() > 0
        && request.resource.data.fullName.size() <= 100;
    }
    
    // Validate job data structure
    function isValidJob() {
      return request.resource.data.keys().hasAll(['posterId', 'title', 'category', 'region', 'city'])
        && request.resource.data.posterId is string
        && request.resource.data.title is string
        && request.resource.data.title.size() > 0
        && request.resource.data.title.size() <= 55
        && request.resource.data.category is string
        && request.resource.data.region is string
        && request.resource.data.city is string;
    }
    
    // Validate application data
    function isValidApplication() {
      return request.resource.data.keys().hasAll(['jobId', 'applicantId'])
        && request.resource.data.jobId is string
        && request.resource.data.applicantId is string
        && request.resource.data.applicantId == request.auth.uid;
    }
    
    // Check if only application-related fields are being updated (for workers applying)
    function onlyUpdatingApplicationFields() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['applicationCount', 'applicationIds']);
    }
    
    // Check if hired worker is rejecting the offer (reverting to active status)
    function isHiredWorkerRejectingOffer() {
      return resource.data.status == 'hired'
        && resource.data.hiredWorkerId == request.auth.uid
        && request.resource.data.status == 'active';
    }
    
    // Check if hired worker is accepting the offer (changing to accepted status)
    function isHiredWorkerAcceptingOffer() {
      return resource.data.status == 'hired'
        && resource.data.hiredWorkerId == request.auth.uid
        && request.resource.data.status == 'accepted';
    }
    
    // Check if hired worker is resigning from the job (after accepting)
    function isHiredWorkerResigning() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return (resource.data.status == 'hired' || resource.data.status == 'accepted')
        && resource.data.hiredWorkerId == request.auth.uid
        && request.resource.data.status == 'active'
        && affectedKeys.hasOnly([
          'status', 'hiredWorkerId', 'hiredWorkerName', 'hiredWorkerThumbnail',
          'agreedPrice', 'hiredAt', 'acceptedAt', 'resignedAt', 'resignReason',
          'resignedWorkerId', 'resignedWorkerName', 'applicationCount', 'lastModified'
        ]);
    }
    
    // Check if customer is marking their hired job as complete
    function isCustomerMarkingComplete() {
      return resource.data.status == 'accepted'
        && resource.data.posterId == request.auth.uid
        && request.resource.data.status == 'completed';
    }
    
    // Check if only updating appliedJobsCount (for job deletion cleanup)
    function isUpdatingAppliedJobsCount() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['appliedJobsCount']);
    }
    
    // Check if only updating statistics fields (for job completion)
    function isUpdatingStatistics() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['statistics']);
    }
    
    // Check if only updating review-related fields (for review submission)
    function isUpdatingReviewStats() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['averageRating', 'totalReviews', 'lastReviewAt']);
    }
    
    // Check if customer is updating their job with review data
    function isCustomerSubmittingReview() {
      return resource.data.posterId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'customerFeedbackSubmitted', 
          'customerFeedbackAt', 
          'customerRating',
          'customerFeedback'
        ]);
    }
    
    // Check if worker is updating their job with review data
    function isWorkerSubmittingReview() {
      return resource.data.hiredWorkerId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'workerFeedbackSubmitted',
          'workerFeedbackAt',
          'workerRating',
          'workerFeedback'
        ]);
    }
    
    // ═══════════════════════════════════════════════════════════════
    // USERS COLLECTION
    // ═══════════════════════════════════════════════════════════════
    match /users/{userId} {
      // Anyone can read any user profile (for displaying poster info, etc.)
      allow read: if true;
      
      // Only authenticated users can create their own profile
      allow create: if isAuthenticated() 
        && request.auth.uid == userId 
        && isValidProfile()
        && request.resource.data.userId == userId;
      
      // Only the owner can update their own profile
      // OR authenticated users can update appliedJobsCount (for job deletion cleanup)
      // OR authenticated users can update statistics (for job completion)
      // OR authenticated users can update review stats (averageRating, totalReviews)
      allow update: if (isOwner(userId)
        && isValidProfile()
        && request.resource.data.userId == userId)
        || (isAuthenticated() && isUpdatingAppliedJobsCount())
        || (isAuthenticated() && isUpdatingStatistics())
        || (isAuthenticated() && isUpdatingReviewStats());
      
      // Only the owner or admin can delete
      allow delete: if isOwner(userId) || isAdmin();
    }
    
    // ═══════════════════════════════════════════════════════════════
    // JOBS COLLECTION
    // ═══════════════════════════════════════════════════════════════
    match /jobs/{jobId} {
      // Anyone can read all jobs (for browsing listings)
      allow read: if true;
      
      // Only authenticated users can create jobs
      allow create: if isAuthenticated()
        && isValidJob()
        && request.resource.data.posterId == request.auth.uid;
      
      // Job poster can update their own job
      // OR any authenticated user can increment applicationCount (when applying)
      // OR hired worker can reject the offer (revert to active)
      // OR hired worker can accept the offer (change to accepted)
      // OR hired worker can resign from the job (after accepting, revert to active)
      // OR customer can mark accepted job as completed
      // OR customer can submit review for completed job
      // OR worker can submit review for completed job
      allow update: if isAuthenticated()
        && (resource.data.posterId == request.auth.uid
            || onlyUpdatingApplicationFields()
            || isHiredWorkerRejectingOffer()
            || isHiredWorkerAcceptingOffer()
            || isHiredWorkerResigning()
            || isCustomerMarkingComplete()
            || isCustomerSubmittingReview()
            || isWorkerSubmittingReview());
      
      // Only the job poster or admin can delete
      allow delete: if isAuthenticated()
        && (resource.data.posterId == request.auth.uid || isAdmin());
    }
    
    // ═══════════════════════════════════════════════════════════════
    // APPLICATIONS COLLECTION
    // ═══════════════════════════════════════════════════════════════
    match /applications/{applicationId} {
      // Users can read their own applications
      // Note: Job posters will query by jobId, so we allow reads for authenticated users
      // and rely on client-side filtering by jobId
      allow read: if isAuthenticated();
      
      // Authenticated users can create applications (but not to their own jobs)
      allow create: if isAuthenticated()
        && isValidApplication()
        && request.resource.data.applicantId == request.auth.uid
        && get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).data.posterId != request.auth.uid;
      
      // Job poster can update application status (hired/rejected)
      // Applicant can update their own application (withdraw, etc.)
      allow update: if isAuthenticated()
        && (resource.data.applicantId == request.auth.uid
            || get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.posterId == request.auth.uid);
      
      // Applicant or job poster can delete
      allow delete: if isAuthenticated()
        && (resource.data.applicantId == request.auth.uid 
            || get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.posterId == request.auth.uid);
    }
    
    // ═══════════════════════════════════════════════════════════════
    // JOB DELETIONS COLLECTION (Audit Log)
    // ═══════════════════════════════════════════════════════════════
    match /job_deletions/{deletionId} {
      // Only admins can read audit logs
      allow read: if isAdmin();
      
      // System can create (through client for now, ideally Cloud Function)
      allow create: if isAuthenticated();
      
      // No updates or deletes allowed (immutable audit trail)
      allow update, delete: if false;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ORPHANED FILES COLLECTION (Future Feature)
    // ═══════════════════════════════════════════════════════════════
    match /orphaned_files/{fileId} {
      // Only admins can read
      allow read: if isAdmin();
      
      // System can create
      allow create: if isAuthenticated();
      
      // Only admins can update/delete
      allow update, delete: if isAdmin();
    }
    
    // ═══════════════════════════════════════════════════════════════
    // REVIEWS COLLECTION
    // ═══════════════════════════════════════════════════════════════
    match /reviews/{reviewId} {
      // Anyone can read reviews (public for profile display)
      allow read: if true;
      
      // Only authenticated users can create reviews for completed jobs
      // Customer reviews worker, or worker reviews customer
      allow create: if isAuthenticated()
        && request.resource.data.reviewerUserId == request.auth.uid
        && request.resource.data.keys().hasAll([
          'reviewId', 'jobId', 'reviewerUserId', 'revieweeUserId',
          'reviewerRole', 'revieweeRole', 'rating', 'feedbackText'
        ])
        && request.resource.data.rating >= 1
        && request.resource.data.rating <= 5;
      
      // Only the review author can update their own review
      allow update: if isAuthenticated()
        && resource.data.reviewerUserId == request.auth.uid;
      
      // Only the review author or admin can delete
      allow delete: if isAuthenticated()
        && (resource.data.reviewerUserId == request.auth.uid || isAdmin());
    }
    
    // ═══════════════════════════════════════════════════════════════
    // MESSAGES/CHAT COLLECTION (Future Feature)
    // ═══════════════════════════════════════════════════════════════
    match /messages/{messageId} {
      // Users can only read messages they're part of
      allow read: if isAuthenticated()
        && (resource.data.senderId == request.auth.uid 
            || resource.data.receiverId == request.auth.uid);
      
      // Authenticated users can create messages
      allow create: if isAuthenticated()
        && request.resource.data.senderId == request.auth.uid;
      
      // No updates or deletes (messages are immutable)
      allow update, delete: if false;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // NOTIFICATIONS COLLECTION (ALERTS Tab in Messages)
    // Cross-user writes are intentional: applicants create notifications
    // for job posters, customers create notifications for workers, etc.
    // ═══════════════════════════════════════════════════════════════
    match /notifications/{notificationId} {
      // Authenticated users can read any notification.
      // This is required so the system can query existing notifications
      // for another user (e.g., checking if a job already has an
      // application_received notification before creating a new one).
      allow read: if isAuthenticated();
      
      // Any authenticated user can create a notification for any recipient.
      // Necessary because notifications are created cross-user client-side.
      allow create: if isAuthenticated()
        && request.resource.data.keys().hasAll(['recipientId', 'type', 'message'])
        && request.resource.data.recipientId is string
        && request.resource.data.type is string;
      
      // Authenticated users can update notifications (mark as read, milestone updates).
      allow update: if isAuthenticated();
      
      // Any authenticated user can delete (needed for duplicate cleanup and
      // removing stale offer notifications on accept/reject).
      allow delete: if isAuthenticated();
    }
    
    // ═══════════════════════════════════════════════════════════════
    // DENY ALL OTHER COLLECTIONS BY DEFAULT
    // ═══════════════════════════════════════════════════════════════
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
